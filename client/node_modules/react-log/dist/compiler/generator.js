'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

/**
 * Code generator will recursively call itself to print each node in
 * the tree into an object with the following schema:
 *
 * {
 *   value: [string formatted to be printed],
 *   styles: [array of ordered set of styles to be applied]
 * }
**/
var generator = function generator(node) {
  var _node$props = node.props,
      children = _node$props.children,
      style = _node$props.style,
      otherProps = _objectWithoutProperties(_node$props, ['children', 'style']);

  // Here we iterate through the ast tree until we run into a leaf node (of type text).


  var renderedChildren = void 0;
  if (node.type !== 'text' && children) {
    if (Array.isArray(children)) {
      // If the node children is an array, we generate each child node
      // and merge it's values and styles.
      renderedChildren = children.map(generator);
      renderedChildren = {
        value: renderedChildren.map(function (child) {
          return child.value;
        }).join(''),
        styles: renderedChildren.reduce(function (accumulator, child) {
          return accumulator.concat(child.styles);
        }, [])
      };
    } else {
      // If the node child is another node, we simply generate it's represetation.
      renderedChildren = generator(children);
    }
  }

  // Prevent generating two consecutive `%c`. This might happen on nesting elements
  var hasStyle = renderedChildren ? renderedChildren.value.indexOf('%c') === 0 : false;
  var stylePrefix = hasStyle ? '' : '%c';

  // Here we mutate the result value or style, regarding the node's type.
  // Ex.
  //  * For a `div` element, we append a new line to generate the `display:block` attribute.
  //  * For a `text` element (leafs of the tree), we simple prepend a `%c` needed to apply styles.
  switch (node.type) {
    case 'body':
    case 'ul':
    case 'ol':
      return renderedChildren;
    case 'span':
      return {
        value: '' + stylePrefix + renderedChildren.value,
        styles: renderedChildren.styles
      };
    case 'div':
    case 'h1':
    case 'h2':
    case 'h3':
    case 'h4':
    case 'h5':
    case 'h6':
    case 'p':
      return {
        value: '' + stylePrefix + renderedChildren.value + '\n',
        styles: renderedChildren.styles
      };
    case 'a':
      var markup = renderedChildren.value ? renderedChildren.value + '  - ' : '';
      var newLine = node.props.display === 'block' ? '\n' : '';

      return {
        value: stylePrefix + markup + node.props.href + newLine,
        styles: renderedChildren.styles
      };
    case 'text':
      return {
        value: '' + children,
        styles: _extends({}, otherProps, style)
      };
    case 'li':
      return {
        value: '' + stylePrefix + node.props.bullet + ' ' + renderedChildren.value + '\n',
        styles: renderedChildren.styles
      };
    case 'img':
      {
        var _node$props2 = node.props,
            src = _node$props2.src,
            width = _node$props2.width,
            height = _node$props2.height,
            _style = _node$props2.style;

        var w = _style && _style.width ? parseInt(_style.width, 10) : width;
        var h = _style && _style.height ? parseInt(_style.height, 10) : height;
        return {
          value: '\n' + stylePrefix + '+\n',
          styles: _extends({
            background: 'url(' + src + ')',
            backgroundSize: w + ' ' + h,
            color: 'transparent',
            fontSize: '1px',
            padding: Math.floor(h / 2) + 'px ' + Math.floor(w / 2) + 'px',
            lineHeight: h + 'px'
          }, _style)
        };
      }
    default:
      throw new TypeError(node.type);
  }
};

exports.default = generator;